Сравнение создания списков (массивов) и организации стеков в Java, Python и C++ (Донцова Анна, УИБО-10-24)

## Создание списка (массива)

### Python
```py
# Создание списка
fruits = ['март', 'апрель', 'май']
fruits.append('июнь')  # Добавление элемента
print(fruits[0])       # Доступ по индексу: 'март'
```
- **Используется встроенный тип list** как динамический массив
- **Динамическая типизация** - не требуется указание типа элементов
- **Литералы квадратных скобок** для создания списка
- **Простой синтаксис** добавления и доступа к элементам
- **Автоматическое управление памятью**

### C++
```cpp
#include <vector>
#include <iostream>

int main() {
    // Создание вектора строк
    std::vector<std::string> fruits = {"март", "апрель", "май"};
    fruits.push_back("июнь");  // Добавление элемента
    std::cout << fruits[0];    // Доступ по индексу: "март"
}
```
- **Используется std::vector** из Standard Template Library (STL)
- **Статическая типизация** - требуется указание типа элементов
- **Требуется подключение заголовочных файлов** (#include <vector>)
- **Высокая производительность** и контроль над памятью
- **Методы push_back()** для добавления элементов в конец

### Java
```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        // Создание ArrayList
        List<String> fruits = new ArrayList<>();
        fruits.add("март");
        fruits.add("апрель"); 
        fruits.add("май");
        fruits.add("июнь");  // Добавление элемента
        System.out.println(fruits.get(0));  // Доступ по индексу: "март"
    }
}
```
- **Используется ArrayList** из Java Collections Framework
- **Статическая типизация** с дженериками (List<String>)
- **Интерфейс List** для абстракции реализации
- **Автоматическое расширение** массива при необходимости
- **Метод add()** для добавления элементов

## Организация стека

### Python
```py
# Создание стека
stack = []
stack.append(1)  # Добавление в стек
stack.append(2)
top = stack.pop()  # Извлечение из стека: 2
```
- **Стек реализуется через стандартный список** (list)
- **Метод append()** для добавления элементов (push)
- **Метод pop()** для извлечения элементов (pop)
- **Простой и интуитивный синтаксис**
- **Динамический размер** стека

### C++
```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> myStack;  // Создание стека
    
    myStack.push(100);  // Добавление элементов
    myStack.push(200);
    myStack.push(300);
    
    while (!myStack.empty()) {
        std::cout << myStack.top() << " ";  // Получение вершины
        myStack.pop();  // Удаление вершины
    }
}
```
- **Используется std::stack** из STL
- **Требуется подключение <stack>**
- **Метод push()** для добавления элементов
- **Метод pop()** для удаления с вершины
- **Метод top()** для получения элемента без удаления
- **Высокая производительность**

### Java
```java
import java.util.Stack;

public class Main {
    public static void main(String[] args) {
        Stack<Integer> numberStack = new Stack<>();
        
        numberStack.push(10);  // Добавление элементов
        numberStack.push(20);
        numberStack.push(30);
        
        int topElement = numberStack.pop();  // Извлечение: 30
        System.out.println(numberStack.peek());  // Просмотр вершины: 20
    }
}
```
- **Используется класс Stack<Integer>** из java.util
- **Дженерик типизация** для безопасности типов
- **Метод push()** для добавления элементов
- **Метод pop()** для извлечения и удаления
- **Метод peek()** для просмотра без удаления
- **Наследование от Vector**

## Сравнительная таблица

| Характеристика | Python | C++ | Java |
|----------------|---------|------|-------|
| **Типизация** | Динамическая | Статическая | Статическая с дженериками |
| **Синтаксис** | Простой | Сложный | Умеренный |
| **Производительность** | Средняя | Высокая | Высокая |
| **Управление памятью** | Автоматическое | Ручное | Автоматическое (GC) |
| **Стандартная библиотека** | Богатая | STL | Collections Framework |
| **Использование памяти** | Высокое | Низкое | Среднее |
| **Кроссплатформенность** | Отличная | Хорошая | Отличная |

## Вывод

Каждый язык предлагает уникальные подходы к работе со структурами данных:

**Python** выделяется минималистичным синтаксисом и простотой использования, предлагая динамические структуры данных "из коробки" ценой некоторой потери производительности. Идеален для быстрого прототипирования и скриптинга.

**C++** предоставляет максимальный контроль над памятью и высочайшую производительность через STL, но требует большего внимания к деталям управления ресурсами и имеет более сложный синтаксис. Оптимален для системного программирования.

**Java** предлагает баланс между производительностью и простотой использования, с строгой типизацией и богатой стандартной библиотекой коллекций. Отличный выбор для кроссплатформенных enterprise-решений.

Выбор языка зависит от конкретных требований проекта: необходимости в производительности (C++), простоте разработки (Python) или типобезопасности и переносимости (Java). Каждый язык имеет свои сильные стороны и оптимальные области применения.
