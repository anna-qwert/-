Исправляю ваш предыдущий запрос, оставляя результаты выполнения алгоритмов.

# Реализация алгоритмов сортировки и поиска

## Алгоритмы сортировки

### 1. **Сортировка выбором (Selection Sort)**

#### Определение:
Алгоритм ищет минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом этой части.

#### Краткое объяснение работы:
- Просматривается вся неотсортированная часть массива для поиска минимального элемента.
- Найденный минимальный элемент переносится в начало неотсортированного участка.
- Процедура повторяется для остальных элементов.

#### Примеры операторов:
- Использование цикла `for` для прохождения по массиву.
- Оператор условия `if` для сравнения элементов.
- Функции `swap()` для обмена местами элементов.

#### Временная сложность:
$\boldsymbol{O(n^2)}$
Почему: После каждого шага минимальной позиции изменяется только один элемент, но для его поиска каждый раз необходим обход оставшихся элементов, что формирует вложенные циклы, дающие квадратичную зависимость.

#### Результат:
```
Исходный массив: 64 25 12 22 11
Отсортированный массив: 11 12 22 25 64
```

---

### 2. **Сортировка пузырьком (Bubble Sort)**

#### Определение:
Проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены неверно.

#### Краткое объяснение работы:
- На каждом шаге алгоритм проводит обход массива, двигая наибольший элемент в конец.
- Проходы продолжаются до тех пор, пока массив не окажется полностью отсортированным.

#### Примеры операторов:
- Цикл `while` или `for` для организации многократных проходов.
- Условие `if` для проверки условий смены элементов.
- Переменная `swapped` для контроля наличия изменений.

#### Временная сложность:
$\boldsymbol{O(n^2)}$
Почему: Независимо от состояния массива, каждый элемент потенциально нуждается в проверке на каждом шаге, формируя двойную вложенность циклов, ведущую к квадратичному росту сложности.

#### Результат:
```
Исходный массив: 64 34 25 12 22 11 90
Отсортированный массив: 11 12 22 25 34 64 90
```

---

### 3. **Сортировка вставками (Insertion Sort)**

#### Определение:
Выбирает элемент и вставляет его на соответствующее место среди уже отсортированных элементов.

#### Краткое объяснение работы:
- Первый элемент считается отсортированным.
- Следующие элементы рассматриваются по очереди и перемещаются в правильную позицию внутри отсортированной части.

#### Примеры операторов:
- Внутренний цикл `while` для перемещения элементов в отсортированной части.
- Сравнения и присваивания для размещения нового элемента.

#### Временная сложность:
$\boldsymbol{O(n^2)}$
Почему: На каждом шаге каждому новому элементу нужно найти свое место среди отсортированных, что часто требует сдвиги, увеличивающие затраты до уровня вложенности циклов.

#### Результат:
```
Исходный массив: 12 11 13 5 6
Отсортированный массив: 5 6 11 12 13
```

---

### 4. **Сортировка слиянием (Merge Sort)**

#### Определение:
Разбивает массив на отдельные элементы, сортирует их и объединяет в правильный порядок.

#### Краткое объяснение работы:
- Массив рекурсивно делится на части до отдельных элементов.
- Отдельные элементы объединяются в отсортированные группы.
- Окончательная сортировка достигается посредством слияния промежуточных результатов.

#### Примеры операторов:
- Рекурсивные вызовы функций для обработки каждой половины массива.
- Организация временного хранилища для сортировки и слияния частей.

#### Временная сложность:
$\boldsymbol{O(n\log{n})}$
Почему: Логарифмическая глубина рекурсии умножается на линейное время для слияния, что дает эффективную комбинацию с оптимальной скоростью.

#### Результат:
```
Исходный массив: 38 27 43 3 9 82 10
Отсортированный массив: 3 9 10 27 38 43 82
```

---

### 5. **Сортировка Шелла (Shell Sort)**

#### Определение:
Модификация сортировки вставками, использующая дополнительные интервалы для ускорения.

#### Краткое объяснение работы:
- Используется серия "промежуточных" шагов, позволяющих сортировать элементы на большем расстоянии друг от друга.
- Промежутки уменьшаются постепенно, заканчивая обычной сортировкой вставками.

#### Примеры операторов:
- Изменение величины шага (`gap`) на каждой итерации.
- Вложенные циклы для анализа и изменения позиций элементов.

#### Временная сложность:
$\boldsymbol{O(n^{1.25})}$
Почему: Введение "больших прыжков" уменьшает количество сравнений и сдвигов на ранних стадиях, ускоряя процесс сортировки.

#### Результат:
```
Исходный массив: 12 34 54 2 3
Отсортированный массив: 2 3 12 34 54
```

---

### 6. **Быстрая сортировка (Quick Sort)**

#### Определение:
Определяет опорный элемент, делит массив на две части и рекурсивно сортирует каждую.

#### Краткое объяснение работы:
- Случайно выбирается опорный элемент.
- Массив делится на две части: элементы, меньшие опорного, и элементы, большие опорного.
- Процесс повторяется рекурсивно для каждой части.

#### Примеры операторов:
- Определение опорного элемента через условие `if`.
- Циклические конструкции для сортировки частей массива.

#### Временная сложность:
$\boldsymbol{O(n\log{n})}$
Почему: Среднее время зависит от эффективного разбиения массива, которое обычно обеспечивает логарифмическое сокращение проблемы, позволяя достичь оптимального быстродействия.

#### Результат:
```
Исходный массив: 10 7 8 9 1 5
Отсортированный массив: 1 5 7 8 9 10
```

---

### 7. **Пирамидальная сортировка (Heap Sort)**

#### Определение:
Создается специальная структура данных (куча), из которой извлекаются элементы в правильном порядке.

#### Краткое объяснение работы:
- Изначально создается дерево-куча (max-heap).
- Наибольший элемент извлекается и добавляется в финальный отсортированный массив.
- Дерево восстанавливается, и процесс повторяется.

#### Примеры операторов:
- Операторы управления деревом (heapify).
- Организация памяти для хранения промежуточных состояний.

#### Временная сложность:
$\boldsymbol{O(n\log{n})}$
Почему: Сложность обусловлена созданием кучи и извлечением элементов, причем оба этапа работают эффективно благодаря свойствам бинарных деревьев, обеспечивая оптимальное время работы.

#### Результат:
```
Исходный массив: 12 11 13 5 6 7
Отсортированный массив: 5 6 7 11 12 13
```

---

## Алгоритмы поиска

### 1. **Последовательный поиск (Sequential Search)**

#### Определение:
Перебирает элементы массива, проверяя каждый элемент по порядку.

#### Краткое объяснение работы:
- Линейно сканируется массив, проверяя наличие требуемого элемента.
- Поиск останавливается сразу после обнаружения элемента или достижения конца массива.

#### Примеры операторов:
- Конструкция цикла `for` для прохождения по массиву.
- Условие `if` для проверки соответствия элемента запросу.

#### Временная сложность:
$\boldsymbol{O(n)}$
Почему: Требуется проверить каждый элемент, особенно в худшем сценарии, когда искомый элемент расположен в конце или вовсе отсутствует.

#### Результат:
```
Индекс элемента 7: 3
```

---

### 2. **Бинарный поиск (Binary Search)**

#### Определение:
Осуществляет поиск в отсортированном массиве, многократно разделяя его на две части.

#### Краткое объяснение работы:
- Берется центральный элемент и сравнивается с целью.
- Если не совпал, поиск продолжается в одной из двух оставшихся частей массива.

#### Примеры операторов:
- Использование цикла `while` для организации повторного деления.
- Условия `if` для принятия решений о дальнейшем поиске.

#### Временная сложность:
$\boldsymbol{O(\log{n})}$
Почему: Массив делится пополам на каждом шаге, что приводит к быстрому сокращению объема исследования и достижению необходимого элемента за минимальное количество проверок.

#### Результат:
```
Индекс элемента 7: 3
```

---

### 3. **Интерполяционный поиск (Interpolation Search)**

#### Определение:
Рассчитывает вероятную позицию элемента на основе текущих значений в массиве.

#### Краткое объяснение работы:
- Оцениваются граничные значения и делается предположение о положении искомого элемента.
- Производятся точные расчеты для сужения зоны поиска.

#### Примеры операторов:
- Расчеты формул для определения ожидаемой позиции.
- Использование циклов для проверки гипотез.

#### Временная сложность:
$\boldsymbol{O(\log{\log{n}})}$
Почему: Используя дополнительную информацию о расположении элементов, удается быстро находить целевой элемент, даже в крупных массивах, значительно снижая количество проверок.

#### Результат:
```
Индекс элемента 85: 8
```

---

### 4. **Фибоначчи-поиск (Fibonacci Search)**

#### Определение:
Использует числа Фибоначчи для эффективного сокращения пространства поиска.

#### Краткое объяснение работы:
- Подбирается номер Фибоначчи, близкий к длине массива.
- Исходя из этого номера осуществляется переход к следующей точке поиска.

#### Примеры операторов:
- Генерация чисел Фибоначчи.
- Управление смещениями в массиве для перехода к новым позициям.

#### Временная сложность:
$\boldsymbol{O(\log{n})}$
Почему: Использование свойств чисел Фибоначчи позволяет быстро перейти к нужной зоне массива, сохраняя логарифмический темп роста затрат времени.

#### Результат:
```
Индекс элемента 85: 8
```
